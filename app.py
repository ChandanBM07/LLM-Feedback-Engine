# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yQCLL643lSMfvZRRsMiQc4ULeHpc5pHA
"""

# app.py
import io
import os
import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt
from wordcloud import WordCloud

# Optional, lightweight fallback sentiment (no big models)
try:
    from textblob import TextBlob
    HAS_TEXTBLOB = True
except Exception:
    HAS_TEXTBLOB = False

st.set_page_config(page_title="üì± App Reviews Analyzer", layout="wide")

st.title("üì± App Reviews Analyzer")
st.caption("Load any CSV (upload, URL, or server path), map columns, and explore.")

# ================
# 1) Load Data
# ================
with st.sidebar:
    st.header("1) Load CSV")
    source = st.radio("Source", ["Upload", "URL", "Server path"], index=0)

    df = None
    if source == "Upload":
        up = st.file_uploader("Upload CSV", type=["csv"])
        if up:
            try:
                df = pd.read_csv(up)
            except Exception as e:
                st.error(f"Could not read uploaded CSV: {e}")

    elif source == "URL":
        url = st.text_input(
            "Paste CSV URL",
            placeholder="https://raw.githubusercontent.com/<user>/<repo>/<branch>/path/to/file.csv",
        )
        if url:
            try:
                df = pd.read_csv(url)
            except Exception as e:
                st.error(f"Could not fetch CSV: {e}")

    else:  # Server path (absolute or relative to app working directory)
        path = st.text_input("Enter server path to CSV", placeholder="data/my_file.csv")
        if path:
            try:
                df = pd.read_csv(path)
            except Exception as e:
                st.error(f"Could not read from path: {e}")

if df is None:
    st.info("‚û°Ô∏è Load a CSV from the sidebar to begin.")
    st.stop()

st.success(f"‚úÖ Loaded {len(df):,} rows, {len(df.columns)} columns")

with st.expander("üîé Preview first 200 rows", expanded=False):
    st.dataframe(df.head(200), use_container_width=True)

# ==========================
# 2) Column Mapping (Flexible)
# ==========================
st.header("2) Map Columns")
st.caption("Tell the app which columns represent App Name, Review Text, Rating, Sentiment, Topic (optional).")

cols = list(df.columns)

def guess_col(candidates):
    for c in cols:
        if str(c).strip().lower() in candidates:
            return c
    return None

# Best-effort guesses
guess_app     = guess_col({"app_name","app","appname","application"})
guess_review  = guess_col({"review","review_text","text","comment","body","content"})
guess_rating  = guess_col({"rating","app_rating","stars","score"})
guess_sent    = guess_col({"sentiment","sentiment_label","hybrid_sentiment_label"})
guess_topic   = guess_col({"topic","theme","label","category"})  # careful: 'category' might be store category

c1, c2, c3 = st.columns(3)
with c1:
    app_col = st.selectbox("App Name column", options=["<none>"] + cols, index=(cols.index(guess_app)+1 if guess_app in cols else 0))
with c2:
    review_col = st.selectbox("Review Text column", options=["<none>"] + cols, index=(cols.index(guess_review)+1 if guess_review in cols else 0))
with c3:
    rating_col = st.selectbox("Rating column (optional)", options=["<none>"] + cols, index=(cols.index(guess_rating)+1 if guess_rating in cols else 0))

c4, c5 = st.columns(2)
with c4:
    sent_col = st.selectbox("Sentiment column (optional)", options=["<none>"] + cols, index=(cols.index(guess_sent)+1 if guess_sent in cols else 0))
with c5:
    topic_col = st.selectbox("Topic column (optional)", options=["<none>"] + cols, index=(cols.index(guess_topic)+1 if guess_topic in cols else 0))

# Build a working frame with normalized names
work = df.copy()

def col_or_none(sel):
    return None if sel == "<none>" else sel

map_app    = col_or_none(app_col)
map_review = col_or_none(review_col)
map_rating = col_or_none(rating_col)
map_sent   = col_or_none(sent_col)
map_topic  = col_or_none(topic_col)

# Guard: need at least Review or Sentiment to analyze
if (map_review is None) and (map_sent is None):
    st.error("Please map at least a **Review Text** column or a **Sentiment** column.")
    st.stop()

# Create normalized columns if present
if map_app:    work["__app__"] = work[map_app].astype(str)
if map_review: work["__review__"] = work[map_review].astype(str)
if map_rating:
    work["__rating__"] = pd.to_numeric(work[map_rating], errors="coerce")
else:
    work["__rating__"] = pd.NA

if map_sent:
    # Normalize sentiment tags to POSITIVE/NEGATIVE/NEUTRAL when possible
    def norm_sent(x):
        s = str(x).strip().lower()
        if "pos" in s: return "POSITIVE"
        if "neg" in s: return "NEGATIVE"
        if "neu" in s or s in {"0","neutral"}: return "NEUTRAL"
        # fallback: keep original
        return str(x)
    work["__sentiment__"] = work[map_sent].apply(norm_sent)
else:
    work["__sentiment__"] = pd.NA

if map_topic:
    work["__topic__"] = work[map_topic].astype(str)
else:
    work["__topic__"] = pd.NA

# Optional quick sentiment if not provided
st.header("3) Analysis Options")
enable_quick_sent = False
if work["__sentiment__"].isna().all():
    if HAS_TEXTBLOB and (map_review is not None):
        enable_quick_sent = st.checkbox("No sentiment found ‚Äî compute quick sentiment with TextBlob (lightweight)", value=True)
    else:
        st.info("No sentiment column mapped. (Install `textblob` to enable quick sentiment, or provide a sentiment column.)")

if enable_quick_sent:
    def tb_label(text):
        try:
            p = TextBlob(str(text)).sentiment.polarity
            if p > 0.1:  return "POSITIVE"
            if p < -0.1: return "NEGATIVE"
            return "NEUTRAL"
        except Exception:
            return "NEUTRAL"
    work["__sentiment__"] = work["__review__"].apply(tb_label)

# Filters
st.header("4) Filters")
cfa, cfb, cfc = st.columns(3)
if "__app__" in work.columns and work["__app__"].notna().any():
    apps = sorted(work["__app__"].dropna().unique().tolist())
    pick_apps = cfa.multiselect("App(s)", apps, default=apps[: min(len(apps), 5)])
else:
    pick_apps = []

if work["__sentiment__"].notna().any():
    sents = sorted(work["__sentiment__"].dropna().unique().tolist())
    pick_sents = cfb.multiselect("Sentiment(s)", sents, default=sents)
else:
    pick_sents = []

if work["__topic__"].notna().any():
    topics = sorted(work["__topic__"].dropna().unique().tolist())
    pick_topics = cfc.multiselect("Topic(s)", topics, default=topics)
else:
    pick_topics = []

kw = st.text_input("üîç Keyword search in reviews (optional)")

# Apply filters safely
filtered = work.copy()
if pick_apps and "__app__" in filtered.columns:
    filtered = filtered[filtered["__app__"].isin(pick_apps)]
if pick_sents and filtered["__sentiment__"].notna().any():
    filtered = filtered[filtered["__sentiment__"].isin(pick_sents)]
if pick_topics and filtered["__topic__"].notna().any():
    filtered = filtered[filtered["__topic__"].isin(pick_topics)]
if kw and "__review__" in filtered.columns:
    filtered = filtered[filtered["__review__"].astype(str).str.contains(kw, case=False, na=False)]

st.success(f"üîé Filtered rows: {len(filtered):,}")

# ================
# 5) Visuals
# ================
st.header("5) Visualizations")
view = st.radio("Choose", ["Sentiment Breakdown", "Topic Distribution", "Word Cloud", "Ratings Histogram"])

# Sentiment Breakdown
if view == "Sentiment Breakdown":
    if "__sentiment__" in filtered.columns and filtered["__sentiment__"].notna().any():
        if "__app__" in filtered.columns and filtered["__app__"].notna().any():
            top_apps = filtered["__app__"].value_counts().head(5).index.tolist()
            sub = filtered[filtered["__app__"].isin(top_apps)].copy()
            if not sub.empty:
                plt.figure(figsize=(10, 5))
                # Use pandas crosstab to avoid seaborn dependency
                ct = pd.crosstab(sub["__app__"], sub["__sentiment__"])
                ct.plot(kind="bar", stacked=False, figsize=(10,5), ax=plt.gca())
                plt.title("Sentiment Breakdown (Top 5 Apps)")
                plt.xticks(rotation=45, ha="right")
                plt.tight_layout()
                st.pyplot(plt.gcf())
            else:
                st.info("Not enough data after filtering.")
        else:
            st.info("App column not mapped or empty; showing overall sentiment.")
            plt.figure(figsize=(6, 4))
            filtered["__sentiment__"].value_counts().plot(kind="bar", ax=plt.gca())
            plt